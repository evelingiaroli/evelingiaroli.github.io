<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Using Types Effectively</title>
<meta name="author" content="(Ben Deane)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../../reveal.js/css/theme/solarized.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Using Types Effectively</h1><h2 class="author">Ben Deane</h2><h2 class="email"><a href="mailto:bdeane@blizzard.com">bdeane@blizzard.com</a></h2><h2 class="date">September 19th, 2016</h2>
</section>

<section>
<section id="slide-orgb4792ce">
<h2 id="orgb4792ce">Using Types Effectively</h2>
</section>
</section>
<section>
<section id="slide-org2143265">
<h2 id="org2143265">What does that mean?</h2>
<br/>
<p>
The recent evolution of C++ is (from one point of view) largely about
<b>strengthening</b> and <b>expanding</b> the <b>capabilities for dealing with types</b>.
</p>

<ul>
<li class="fragment appear">expansion of <code>type_traits</code></li>
<li class="fragment appear"><code>decltype</code> to utter types</li>
<li class="fragment appear"><code>auto</code> to preserve types, prevent conversions, infer return types</li>
<li class="fragment appear"><code>nullptr</code> to prevent <code>int</code> / pointer confusion</li>
<li class="fragment appear">scoped <code>enum</code></li>
<li class="fragment appear">GSL: <code>owner&lt;T&gt;</code>, <code>not_null&lt;T&gt;</code></li>
<li class="fragment appear">Concepts TS</li>

</ul>

<aside class="notes">
<p>
Some of the features added to modern C++ to deal with types.
</p>

<p>
Obviously someone thinks that types are important. And the ability to wrangle
them and mould them to our purposes is an important part of C++.
</p>

<p>
Types are the currency of metaprogramming, but also important for safety in
"regular" programming; hence we see things like the GSL's <code>owner&lt;&gt;</code> and <code>not_null&lt;&gt;</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgd8c11ef">
<h2 id="orgd8c11ef">FP isn't (only) about</h2>
<br/>
<ul>
<li class="fragment appear">first class functions</li>
<li class="fragment appear">higher order functions</li>
<li class="fragment appear">lexical scoping, closures</li>
<li class="fragment appear">pattern matching</li>
<li class="fragment appear">value semantics</li>
<li class="fragment appear">immutability</li>
<li class="fragment appear">concurrency through immutability</li>
<li class="fragment appear">laziness</li>
<li class="fragment appear">garbage collection</li>
<li class="fragment appear">boxed data types / "inefficient" runtime models</li>
<li class="fragment appear">the M-word</li>

</ul>

<aside class="notes">
<p>
Functional languages can teach us a thing or two about types. (After all, they
seem to be teaching us everything else.)
</p>

<p>
Here are some things you may think of when functional programming is mentioned&#x2026;
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgff0193e">
<h2 id="orgff0193e">FP is (also, importantly) about</h2>
<br/>
<ul>
<li class="fragment appear">using types effectively and expressively</li>
<li class="fragment appear">making illegal states unrepresentable</li>
<li class="fragment appear">making illegal behaviour result in a type error</li>
<li class="fragment appear">using total functions for easier to use, harder to misuse interfaces</li>

</ul>

<aside class="notes">
<p>
These aspects of functional programming are often overlooked.
</p>

<p>
Many functional languages have well-developed, expressive type systems.
</p>

<p>
C++ is moving in that direction.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org1370d71">
<h2 id="org1370d71">What is a type?</h2>
<br/>
<ul>
<li class="fragment appear">A way for the compiler to know what opcodes to output (dmr's motivation)?</li>
<li class="fragment appear">The way data is stored (representational)?</li>
<li class="fragment appear">Characterised by what operations are possible (behavioural)?</li>
<li class="fragment appear">Determines the values that can be assigned?</li>
<li class="fragment appear">Determines the meaning of the data?</li>

</ul>

</section>
</section>
<section>
<section id="slide-org18b2bde">
<h2 id="org18b2bde">What is a type?</h2>

<div class="figure">
<p><img src="./int_bool_1.png" alt="int_bool_1.png" />
</p>
</div>

<p>
"Only Lua would have '<code>1 == true</code>' evaluate to <code>false</code>. #wantmydayback"
</p>

<div class="fragment appear">

<div class="figure">
<p><img src="./int_bool_2.png" alt="int_bool_2.png" />
</p>
</div>

<p>
"But, how can <code>1</code> be equal to <code>true</code>? <code>1</code> is an integer, and <code>true</code> is a boolean. Lua
seems to be correct here. It's your view of the world that has been warped."
</p>

<p>
(Smiley faces make criticism OK!)
</p>
</div>

</section>
</section>
<section>
<section id="slide-org1661ddd">
<h2 id="org1661ddd">What is a type?</h2>
<br/>
<ul>
<li class="fragment appear">The set of values that can inhabit an expression
<ul>
<li>may be finite or "infinite"</li>
<li>characterized by cardinality</li>

</ul></li>
<li class="fragment appear">Expressions have types
<ul>
<li>A program has a type</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org0807d39">
<h2 id="org0807d39">Let's play a game</h2>
<p class="fragment appear">
To help us get thinking about types.
</p>

<p class="fragment appear">
I'll tell you a type.
</p>

<p class="fragment appear">
You tell me how many values it has.
</p>

<p class="fragment appear">
There are no tricks: if it seems obvious, it is!
</p>

</section>
</section>
<section>
<section id="slide-org4058e90">
<h2 id="org4058e90">Level 1</h2>
<br/>
<p>
Types as sets of values
</p>

</section>
</section>
<section>
<section id="slide-org0a54b97">
<h2 id="org0a54b97">Level 1</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #5BA0EB;">bool</span>;
</pre>
</div>

<p class="fragment appear">
2 (<code>true</code> and <code>false</code>)
</p>

</section>
</section>
<section>
<section id="slide-org6581833">
<h2 id="org6581833">Level 1</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #5BA0EB;">char</span>;
</pre>
</div>

<p class="fragment appear">
256
</p>

</section>
</section>
<section>
<section id="slide-org017bcad">
<h2 id="org017bcad">Level 1</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #5BA0EB;">void</span>;
</pre>
</div>

<p class="fragment appear">
0
</p>

<div class="org-src-container">

<pre  class="fragment appear"><span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Foo</span> { <span style="color: #AF81F4;">Foo</span>() = <span style="color: #8AC6F2;">delete</span>; };
</pre>
</div>

<div class="org-src-container">

<pre  class="fragment appear"><span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Bar</span> { <span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt; <span style="color: #AF81F4;">Bar</span>(); };
</pre>
</div>

<aside class="notes">
<p>
cf BASIC's function vs procedure
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org53033ed">
<h2 id="org53033ed">Level 1</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Foo</span> {};
</pre>
</div>

<p class="fragment appear">
1
</p>

</section>
</section>
<section>
<section id="slide-orgc31875b">
<h2 id="orgc31875b">Level 1</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">enum</span> <span style="color: #5BA0EB;">FireSwampDangers</span> : int8_t {
  <span style="color: #8AC6F2;">FLAME_SPURTS</span>,
  <span style="color: #8AC6F2;">LIGHTNING_SAND</span>,
  <span style="color: #8AC6F2;">ROUSES</span>
};
</pre>
</div>

<p class="fragment appear">
3
</p>

<aside class="notes">
<p>
It is possible to put something into FireSwampDangers that fits
representationally (eg. the value 4). But that would be meaningless: there would
be no connection between the value represented and its interpretation. Because
there is no interpretation: cf. an unconstructed object.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org14c6f6e">
<h2 id="org14c6f6e">Level 1</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Foo</span> {
  <span style="color: #5BA0EB;">T</span> <span style="color: #8AC6F2;">m_t</span>;
};
</pre>
</div>

<p class="fragment appear">
<code>Foo</code> has as many values as <code>T</code>
</p>

</section>
</section>
<section>
<section id="slide-org5ea96ec">
<h2 id="org5ea96ec">End of Level 1</h2>
<p>
Algebraically, a type is the number of values that inhabit it.
</p>

<p>
These types are equivalent:
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #5BA0EB;">bool</span>;

<span style="color: #8AC6F2;">enum</span> <span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">InatorButtons</span> {
  <span style="color: #8AC6F2;">ON_OFF</span>,
  <span style="color: #8AC6F2;">SELF_DESTRUCT</span>
};
</pre>
</div>

<p class="fragment appear">
Let's move on to level 2.
</p>

</section>
</section>
<section>
<section id="slide-orgf373f41">
<h2 id="orgf373f41">Level 2</h2>
<br/>
<p>
Aggregating Types
</p>

</section>
</section>
<section>
<section id="slide-orgac5b515">
<h2 id="orgac5b515">Level 2</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">pair</span>&lt;<span style="color: #5BA0EB;">char</span>, <span style="color: #5BA0EB;">bool</span>&gt;;
</pre>
</div>

<p class="fragment appear">
256 * 2 = 512
</p>

</section>
</section>
<section>
<section id="slide-org69b64b2">
<h2 id="org69b64b2">Level 2</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Foo</span> {
  <span style="color: #5BA0EB;">char</span> <span style="color: #8AC6F2;">a</span>;
  <span style="color: #5BA0EB;">bool</span> <span style="color: #8AC6F2;">b</span>;
};
</pre>
</div>

<p class="fragment appear">
256 * 2 = 512
</p>

</section>
</section>
<section>
<section id="slide-orgb39392b">
<h2 id="orgb39392b">Level 2</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">tuple</span>&lt;<span style="color: #5BA0EB;">bool</span>, <span style="color: #5BA0EB;">bool</span>, <span style="color: #5BA0EB;">bool</span>&gt;;
</pre>
</div>

<p class="fragment appear">
2 * 2 * 2 = 8
</p>

</section>
</section>
<section>
<section id="slide-orge619146">
<h2 id="orge619146">Level 2</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>, <span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">U</span>&gt;
<span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Foo</span> {
  <span style="color: #5BA0EB;">T</span> <span style="color: #8AC6F2;">m_t</span>;
  <span style="color: #5BA0EB;">U</span> <span style="color: #8AC6F2;">m_u</span>;
};
</pre>
</div>

<p class="fragment appear">
(# of values in <code>T</code>) * (# of values in <code>U</code>)
</p>

</section>
</section>
<section>
<section id="slide-org8890388">
<h2 id="org8890388">End of Level 2</h2>
<p>
When two types are "concatenated" into one compound type, we <span class="underline">multiply</span> the # of
inhabitants of the components.
</p>

<p>
This kind of compounding gives us a <span class="underline">product type</span>.
</p>

<p class="fragment appear">
On to Level 3.
</p>

</section>
</section>
<section>
<section id="slide-orga3cb09a">
<h2 id="orga3cb09a">Level 3</h2>
<br/>
<p>
Alternating Types
</p>

</section>
</section>
<section>
<section id="slide-org02caa68">
<h2 id="org02caa68">Level 3</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">optional</span>&lt;<span style="color: #5BA0EB;">char</span>&gt;;
</pre>
</div>

<p class="fragment appear">
256 + 1 = 257
</p>

</section>
</section>
<section>
<section id="slide-org3467683">
<h2 id="org3467683">Level 3</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">variant</span>&lt;<span style="color: #5BA0EB;">char</span>, <span style="color: #5BA0EB;">bool</span>&gt;;
</pre>
</div>

<p class="fragment appear">
256 + 2 = 258
</p>

</section>
</section>
<section>
<section id="slide-orgdbf0e59">
<h2 id="orgdbf0e59">Level 3</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>, <span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">U</span>&gt;
<span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Foo</span> {
  <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">variant</span>&lt;<span style="color: #5BA0EB;">T</span>, <span style="color: #5BA0EB;">U</span>&gt;;
}
</pre>
</div>

<p class="fragment appear">
(# of values in <code>T</code>) + (# of values in <code>U</code>)
</p>

</section>
</section>
<section>
<section id="slide-orgdeb6246">
<h2 id="orgdeb6246">End of Level 3</h2>
<p>
When two types are "alternated" into one compound type, we <span class="underline">add</span> the # of
inhabitants of the components.
</p>

<p>
This kind of compounding gives us a <span class="underline">sum type</span>.
</p>

</section>
</section>
<section>
<section id="slide-org5024acb">
<h2 id="org5024acb">Level 4</h2>
<br/>
<p>
Function Types
</p>

</section>
</section>
<section>
<section id="slide-orgd7568c4">
<h2 id="orgd7568c4">Level 4</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5BA0EB;">bool</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">bool</span>);
</pre>
</div>

<p class="fragment appear">
4
</p>

</section>
</section>
<section>
<section id="slide-org477269f">
<h2 id="org477269f">Level 4</h2>
<p>
Four possible values
 <object type="image/svg+xml" data="./function_bool.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

</section>
</section>
<section>
<section id="slide-orgb96b753">
<h2 id="orgb96b753">Level 4</h2>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5BA0EB;">bool</span> <span style="color: #AF81F4;">f1</span>(<span style="color: #5BA0EB;">bool</span> <span style="color: #8AC6F2;">b</span>) { <span style="color: #8AC6F2;">return</span> b; }
<span style="color: #5BA0EB;">bool</span> <span style="color: #AF81F4;">f2</span>(<span style="color: #5BA0EB;">bool</span>) { <span style="color: #8AC6F2;">return</span> <span style="color: #FFC287;">true</span>; }
<span style="color: #5BA0EB;">bool</span> <span style="color: #AF81F4;">f3</span>(<span style="color: #5BA0EB;">bool</span>) { <span style="color: #8AC6F2;">return</span> <span style="color: #FFC287;">false</span>; }
<span style="color: #5BA0EB;">bool</span> <span style="color: #AF81F4;">f4</span>(<span style="color: #5BA0EB;">bool</span> <span style="color: #8AC6F2;">b</span>) { <span style="color: #8AC6F2;">return</span> <span style="color: #C62626;">!</span>b; }
</pre>
</div>

</section>
</section>
<section>
<section id="slide-orgce51d45">
<h2 id="orgce51d45">Level 4</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #5BA0EB;">char</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">bool</span>);
</pre>
</div>

<p class="fragment appear">
256 * 256 = 65,536
</p>

</section>
</section>
<section>
<section id="slide-orgbb63ae8">
<h2 id="orgbb63ae8">Level 4</h2>
<p>
How many values (for <code>f</code>)?
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #8AC6F2;">enum</span> <span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">Foo</span>
{
  <span style="color: #8AC6F2;">BAR</span>,
  <span style="color: #8AC6F2;">BAZ</span>,
  <span style="color: #8AC6F2;">QUUX</span>
};
<span style="color: #5BA0EB;">char</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">Foo</span>);
</pre>
</div>

<p class="fragment appear">
256 * 256 * 256 = 16,777,216
</p>

</section>
</section>
<section>
<section id="slide-org4745062">
<h2 id="org4745062">Level 4</h2>
<p>
The number of values of a function is the number of different ways we can draw
arrows between the inputs and the outputs.
 <object type="image/svg+xml" data="./function.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>

</section>
</section>
<section>
<section id="slide-org69cc650">
<h2 id="org69cc650">Level 4</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">T</span>, <span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">U</span>&gt;
<span style="color: #5BA0EB;">U</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">T</span>);
</pre>
</div>

<p class="fragment appear">
\(|U|^{|T|}\)
</p>

</section>
</section>
<section>
<section id="slide-org3559ed5">
<h2 id="org3559ed5">End of Level 4</h2>
<p>
When we have a <span class="underline">function</span> from \(A\) to \(B\), we raise the # of inhabitants of
\(B\) to the power of the # of inhabitants of \(A\).
</p>

</section>
</section>
<section>
<section id="slide-org386ed15">
<h2 id="org386ed15">End of Level 4 (corollary)</h2>
<p>
Hence a curried function is equivalent to its uncurried alternative.
</p>


<p>
\[\begin{align*}
F_{uncurried}::(A,B) \rightarrow C & \Leftrightarrow C^{A*B} \\
& = C^{B*A} \\
& = (C^B)^A \\
& \Leftrightarrow (B \rightarrow C)^A \\
& \Leftrightarrow F_{curried}::A \rightarrow (B \rightarrow C)
\end{align*}\]
</p>

</section>
</section>
<section>
<section id="slide-org5533bab">
<h2 id="org5533bab">Victory!</h2>
<br/><br/><div id="achv"><div class="achievement-banner"><div class="achievement-icon"><span class="icon"><span class="icon-trophy">&#127942;</span></span></div><div class="achievement-text"><p class="achievement-notification">ACHIEVEMENT UNLOCKED</p><p class="achievement-name">Algebraic Datatypes 101</p></div></div></div>

</section>
</section>
<section>
<section id="slide-org360d5d9">
<h2 id="org360d5d9">Equivalences</h2>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Foo</span> {
  <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">variant</span>&lt;<span style="color: #5BA0EB;">T</span>, <span style="color: #5BA0EB;">T</span>&gt; <span style="color: #8AC6F2;">m_v</span>;
};

<span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Bar</span> {
  <span style="color: #5BA0EB;">T</span> <span style="color: #8AC6F2;">m_t</span>;
  <span style="color: #5BA0EB;">bool</span> <span style="color: #8AC6F2;">m_b</span>;
};
</pre>
</div>

<p>
We have a choice over how to represent values. <code>std::variant</code> will quickly
become a very important tool for proper expression of states.
</p>

<p>
This is one reason why <code>std::variant</code>'s "never-empty" guarantee is important.
</p>

<aside class="notes">
<p>
T + T = 2T.
</p>

<p>
But note that in <code>Bar</code>, we need to manually keep the two variables "in sync".
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0c0386f">
<h2 id="org0c0386f">Algebraic Datatypes</h2>
<p>
This is what it means to have an algebra of datatypes.
</p>

<ul>
<li class="fragment appear">the ability to reason about equality of types</li>
<li class="fragment appear">to find equivalent formulations
<ul>
<li>more natural</li>
<li>more easily understood</li>
<li>more efficient</li>

</ul></li>
<li class="fragment appear">to identify mismatches between state spaces and the types used to implement
them</li>
<li class="fragment appear">to eliminate illegal states by making them inexpressible</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgee9cb3a">
<h2 id="orgee9cb3a">Making Illegal States Unrepresentable</h2>
<p>
<code>std::variant</code> is a game changer because it allows us to (more) properly express
types, so that (more) illegal states are unrepresentable.
</p>


<div class="figure">
<p><img src="./variant-tweet.png" alt="variant-tweet.png" />
</p>
</div>

<aside class="notes">
<p>
C++'s type system is still not perfect by a long shot. But <code>std::variant</code> is an
amazing upgrade.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org96d7efa">
<h2 id="org96d7efa">Making Illegal States Unrepresentable</h2>
<p>
Let's look at some possible alternative data formulations, using sum types
(<code>variant</code>, <code>optional</code>) as well as product types (structs).
</p>

</section>
</section>
<section>
<section id="slide-org9d19865">
<h2 id="org9d19865">Example: Connection State</h2>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">enum</span> <span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">ConnectionState</span> {
  <span style="color: #8AC6F2;">DISCONNECTED</span>,
  <span style="color: #8AC6F2;">CONNECTING</span>,
  <span style="color: #8AC6F2;">CONNECTED</span>,
  <span style="color: #8AC6F2;">CONNECTION_INTERRUPTED</span>
};

<span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Connection</span> {
  <span style="color: #5BA0EB;">ConnectionState</span> <span style="color: #8AC6F2;">m_connectionState</span>;

  <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">string</span> <span style="color: #8AC6F2;">m_serverAddress</span>;
  <span style="color: #5BA0EB;">ConnectionId</span> <span style="color: #8AC6F2;">m_id</span>;
  <span style="color: #FFC287;">std</span>::<span style="color: #FFC287;">chrono</span>::<span style="color: #FFC287;">system_clock</span>::<span style="color: #5BA0EB;">time_point</span> <span style="color: #8AC6F2;">m_connectedTime</span>;
  <span style="color: #FFC287;">std</span>::<span style="color: #FFC287;">chrono</span>::<span style="color: #5BA0EB;">milliseconds</span> <span style="color: #8AC6F2;">m_lastPingTime</span>;
  <span style="color: #5BA0EB;">Timer</span> <span style="color: #8AC6F2;">m_reconnectTimer</span>;
};
</pre>
</div>

<aside class="notes">
<p>
A very simple example of what a connection class might look like today.
</p>

<p>
Functions interacting with this class would typically use a switch statement
over the <code>ConnectionState</code>.
</p>

<p>
There are hidden invariants here that aren't enforced by the Connection type.
</p>

<p>
Some of the fields are dependent on the connection state (reconnect time, last
ping time). So it seems that some of these fields need sentinel values (eg
invalid connection id).
</p>

<p>
Worse, there is temptation to reuse fields for multiple states. Connected
timestamp is perhaps likely to get reused to mean the instant of connection and
the instant of disconnection.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgf62df30">
<h2 id="orgf62df30">Example: Connection State</h2>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Connection</span> {
  <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">string</span> <span style="color: #8AC6F2;">m_serverAddress</span>;

  <span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Disconnected</span> {};
  <span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Connecting</span> {};
  <span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Connected</span> {
    <span style="color: #5BA0EB;">ConnectionId</span> <span style="color: #8AC6F2;">m_id</span>;
    <span style="color: #FFC287;">std</span>::<span style="color: #FFC287;">chrono</span>::<span style="color: #FFC287;">system_clock</span>::<span style="color: #5BA0EB;">time_point</span> <span style="color: #8AC6F2;">m_connectedTime</span>;
    <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">optional</span>&lt;<span style="color: #FFC287;">std</span>::<span style="color: #FFC287;">chrono</span>::milliseconds&gt; <span style="color: #8AC6F2;">m_lastPingTime</span>;
  };
  <span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">ConnectionInterrupted</span> {
    <span style="color: #FFC287;">std</span>::<span style="color: #FFC287;">chrono</span>::<span style="color: #FFC287;">system_clock</span>::<span style="color: #5BA0EB;">time_point</span> <span style="color: #8AC6F2;">m_disconnectedTime</span>;
    <span style="color: #5BA0EB;">Timer</span> <span style="color: #8AC6F2;">m_reconnectTimer</span>;
  };

  <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">variant</span>&lt;<span style="color: #5BA0EB;">Disconnected</span>,
               <span style="color: #5BA0EB;">Connecting</span>,
               <span style="color: #5BA0EB;">Connected</span>,
               <span style="color: #5BA0EB;">ConnectionInterrupted</span>&gt; <span style="color: #8AC6F2;">m_connection</span>;
};
</pre>
</div>

<aside class="notes">
<p>
With types structured correctly, it's not possible to express illegal states.
</p>

<p>
e.g. Ping time does not exist if we're not connected.
</p>

<p>
(There are still things that are common to all states, e.g. perhaps this class
represents connection to a specific server.)
</p>

<p>
A switch statement could still exist, switching on the <code>variant</code>'s <code>index()</code>, or
a visitor-based approach could be used.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org5a33e05">
<h2 id="org5a33e05">Example: Nullable field</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">Friend</span> {
  <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">string</span> <span style="color: #8AC6F2;">m_alias</span>;
  <span style="color: #5BA0EB;">bool</span> <span style="color: #8AC6F2;">m_aliasPopulated</span>;
  ...
};
</pre>
</div>
<p>
These two fields need to be kept in sync everywhere.
</p>

<aside class="notes">
<p>
Here, a field is populated from a remote source and happens lazily and/or
asynchronously. It is possible that the field never gets populated.
</p>

<p>
All the code that deals with this field has to ensure that both variables are
kept up to date in sync with each other.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org14b1b1b">
<h2 id="org14b1b1b">Example: Nullable field</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">Friend</span> {
  <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">optional</span>&lt;<span style="color: #FFC287;">std</span>::string&gt; <span style="color: #8AC6F2;">m_alias</span>;
  ...
};
</pre>
</div>
<p>
<code>std::optional</code> provides a sentinel value that is outside the type.
</p>

<aside class="notes">
<p>
<code>std::optional</code> captures the true state space of the variable. It is not
possible for two fields to get out of step now.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org96b85f1">
<h2 id="org96b85f1">Example: Monster AI</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">enum</span> <span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">AggroState</span> {
  <span style="color: #8AC6F2;">IDLE</span>,
  <span style="color: #8AC6F2;">CHASING</span>,
  <span style="color: #8AC6F2;">FIGHTING</span>
};

<span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">MonsterAI</span> {
  <span style="color: #5BA0EB;">AggroState</span> <span style="color: #8AC6F2;">m_aggroState</span>;

  <span style="color: #5BA0EB;">float</span> <span style="color: #8AC6F2;">m_aggroRadius</span>;
  <span style="color: #5BA0EB;">PlayerId</span> <span style="color: #8AC6F2;">m_target</span>;
  <span style="color: #5BA0EB;">Timer</span> <span style="color: #8AC6F2;">m_chaseTimer</span>;
};
</pre>
</div>

<aside class="notes">
<p>
Once again, presumably PlayerId has some invalid sentinel value.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgdad6924">
<h2 id="orgdad6924">Example: Monster AI</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">MonsterAI</span> {
  <span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Idle</span> {
    <span style="color: #5BA0EB;">float</span> <span style="color: #8AC6F2;">m_aggroRadius</span>;
  };
  <span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Chasing</span> {
    <span style="color: #5BA0EB;">PlayerId</span> <span style="color: #8AC6F2;">m_target</span>;
    <span style="color: #5BA0EB;">Timer</span> <span style="color: #8AC6F2;">m_chaseTimer</span>;
  };
  <span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">Fighting</span> {
    <span style="color: #5BA0EB;">PlayerId</span> <span style="color: #8AC6F2;">m_target</span>;
  };

  <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">variant</span>&lt;<span style="color: #5BA0EB;">Idle</span>, <span style="color: #5BA0EB;">Chasing</span>, <span style="color: #5BA0EB;">Fighting</span>&gt; <span style="color: #8AC6F2;">m_aggroState</span>;
};
</pre>
</div>

<aside class="notes">
<p>
Now the variables are properly placed into the states that use them.
</p>

<p>
Chasing and Fighting states could inherit from an Aggroed state that holds a target.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org27a9c8c">
<h2 id="org27a9c8c">Example: Design Patterns</h2>
<p>
The addition of sum types to C++ offers an alternative formulation for some
design patterns.
</p>

<p>
State machines and expressions are naturally modelled with sum types.
</p>

<aside class="notes">
<p>
Traditional runtime polymorphism approach can lead to bloated base class issue.
</p>

<p>
Type erasure is another way to go.
</p>

<p>
Sum types + visitor/pattern matching is a third possibility, particularly
natural for things like ASTs.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc9d7493">
<h2 id="orgc9d7493">Example: Design Patterns</h2>
<ul>
<li>Command</li>
<li>Composite</li>
<li>State</li>
<li>Interpreter</li>

</ul>

<aside class="notes">
<p>
Command uses a flat, wide class hierarchy to encapsulate requests in objects.
</p>

<p>
Composite: model part-whole hierarchies with uniform interface.
</p>

<p>
State is obvious: simply replace the contained polymorphic object with a
variant.
</p>

<p>
Sum types are especially good for representing expressions (think JSON).
</p>

<p>
Interpreter tackles the expression problem: easy to add new classes (use
OO/interfaces) or new operations (use sum types/visitors)?
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org4de7248">
<h2 id="org4de7248">Designing with Types</h2>
<br/>
<p>
<code>std::variant</code> and <code>std::optional</code> are valuable tools that allow us to model the
state of our business logic more accurately.
</p>

<p>
When you match the types to the domain accurately, certain categories of tests
just disappear.
</p>

<aside class="notes">
<p>
You don't have to test the edge cases where the representation can fall outside
your reality - because that can't happen.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org1448813">
<h2 id="org1448813">Designing with Types</h2>
<br/>
<p>
Fitting types to their function more accurately makes code easier to understand
and removes pitfalls.
</p>

<p>
The bigger the codebase and the more vital the functionality, the more value
there is in correct representation with types.
</p>

<aside class="notes">
<p>
When illegal states are unrepresentable, you don't have to worry about other
programmers misunderstanding the code, or misusing data. In a sense, they
<i>cannot</i> write something that is wrong.
</p>

<p>
And when I say "other programmers" of course I mean myself in 3 months&#x2026;
</p>

<p>
Questionably reusing fields, bending semantics, etc. These are bad practices.
But they happen when we're chasing a deadline.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgfd945ec">
<h2 id="orgfd945ec">Using Types to Constrain Behaviour</h2>
<br/>
<p>
We've seen how an expressive type system (with product and sum types) allows us
to model state more accurately.
</p>

<p>
"Phantom types" is one technique that helps us to model the <i>behaviour</i> of our
business logic in the type system. Illegal behaviour becomes a type error.
</p>

</section>
</section>
<section>
<section id="slide-org3f46879">
<h2 id="org3f46879">Phantom Types: Before</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">string</span> <span style="color: #AF81F4;">GetFormData</span>();

<span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">string</span> <span style="color: #AF81F4;">SanitizeFormData</span>(<span style="color: #8AC6F2;">const</span> <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">string</span>&amp;);

<span style="color: #5BA0EB;">void</span> <span style="color: #AF81F4;">ExecuteQuery</span>(<span style="color: #8AC6F2;">const</span> <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">string</span>&amp;);
</pre>
</div>
<p>
An injection bug waiting to happen.
</p>

<aside class="notes">
<p>
Let's hope we don't meet little Bobby Tables, and that everywhere we execute a
query we remembered to sanitize the data provided by the user.
</p>

<p>
The type system is not helping us here. How can we use types to make sure that
we stay safe?
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org6be418e">
<h2 id="org6be418e">Phantom Types: The setup</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">FormData</span> {
  <span style="color: #8AC6F2;">explicit</span> <span style="color: #AF81F4;">FormData</span>(<span style="color: #8AC6F2;">const</span> <span style="color: #5BA0EB;">string</span>&amp; <span style="color: #8AC6F2;">input</span>) : m_input(input) {}
  <span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">string</span> <span style="color: #8AC6F2;">m_input</span>;
};

<span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">sanitized</span> {};
<span style="color: #8AC6F2;">struct</span> <span style="color: #5BA0EB;">unsanitized</span> {};
</pre>
</div>
<p>
<code>T</code> is the "Phantom Type" here.
</p>

<aside class="notes">
<p>
Note that the template argument is unused. It exists <span class="underline">only</span> for compile time
type checking. There is no runtime overhead.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgbef78d7">
<h2 id="orgbef78d7">Phantom Types: After</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #5BA0EB;">FormData</span>&lt;unsanitized&gt; <span style="color: #AF81F4;">GetFormData</span>();

<span style="color: #FFC287;">std</span>::<span style="color: #5BA0EB;">optional</span>&lt;<span style="color: #5BA0EB;">FormData</span>&lt;sanitized&gt;&gt;
<span style="color: #AF81F4;">SanitizeFormData</span>(<span style="color: #8AC6F2;">const</span> <span style="color: #5BA0EB;">FormData</span>&lt;unsanitized&gt;&amp;);

<span style="color: #5BA0EB;">void</span> <span style="color: #AF81F4;">ExecuteQuery</span>(<span style="color: #8AC6F2;">const</span> <span style="color: #5BA0EB;">FormData</span>&lt;sanitized&gt;&amp;);
</pre>
</div>

<aside class="notes">
<p>
User input is born unsanitized.
</p>

<p>
It is impossible for us to execute unsanitized input. The compiler simply won't
compile it.
</p>

<p>
We've used types to help enforce the business logic.
</p>

<p>
This is something similar to a strong typedef, or what enum class effectively
does for integral types. This technique can also be used e.g. in a units
library.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgc5f4b02">
<h2 id="orgc5f4b02">Total Functions</h2>
<br/>
<p>
A <i>total function</i> is a function that is defined for all inputs in its domain.
</p>

<p class="fragment appear">
<code>template &lt;typename T&gt;
const T&amp; min(const T&amp; a, const T&amp; b);</code>
</p>

<p class="fragment appear">
<code>float sqrt(float f);</code>
</p>

<aside class="notes">
<p>
We are straying into the realm of Concepts here.
</p>

<p>
I'm not saying that total is the same thing as "no preconditions". The type must
satisfy the requirements on it. But you can see that with functions like <code>sqrt</code>
there is a clear mismatch between the type of the function and the actual type
of its domain.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org980d8fd">
<h2 id="org980d8fd">Let's play another game</h2>
<p class="fragment appear">
To help us see how total functions with the right types can result in
unsurprising code.
</p>

<p class="fragment appear">
I'll give you a function signature with no names attached.
</p>

<p class="fragment appear">
You tell me what it's called&#x2026; (and you'll even know how to implement it).
</p>

<p class="fragment appear">
The only rule&#x2026; it must be a <i>total</i> function.
</p>

<aside class="notes">
<p>
Assume regular types. Assume that the function is doing something "interesting"
rather than "boring" when you have a choice. (ie. that it uses its argument).
But you needn't assume anything else.
</p>

<p>
And there are always ways to make things unexpected in C++. But assume nothing
surprising here.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgd87cffe">
<h2 id="orgd87cffe">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #5BA0EB;">T</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">T</span>);
</pre>
</div>

<p class="fragment appear">
<code>identity</code>
</p>

<div class="org-src-container">

<pre  class="fragment appear"><span style="color: #5BA0EB;">int</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">int</span>);
</pre>
</div>

<aside class="notes">
<p>
Note the odd situation here: we know more about <code>f(T)</code> than we do about
<code>f(int)</code>.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orge3aa48c">
<h2 id="orge3aa48c">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>, <span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">U</span>&gt;
<span style="color: #5BA0EB;">T</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">pair</span>&lt;<span style="color: #5BA0EB;">T</span>, <span style="color: #5BA0EB;">U</span>&gt;);
</pre>
</div>

<p class="fragment appear">
<code>first</code>
</p>

</section>
</section>
<section>
<section id="slide-orgd925cd5">
<h2 id="orgd925cd5">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #5BA0EB;">T</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">bool</span>, <span style="color: #5BA0EB;">T</span>, <span style="color: #5BA0EB;">T</span>);
</pre>
</div>

<p class="fragment appear">
<code>select</code>
</p>

</section>
</section>
<section>
<section id="slide-orgd56e4b6">
<h2 id="orgd56e4b6">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>, <span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">U</span>&gt;
<span style="color: #5BA0EB;">U</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">function</span>&lt;<span style="color: #AF81F4;">U</span>(<span style="color: #5BA0EB;">T</span>)&gt;, <span style="color: #5BA0EB;">T</span>);
</pre>
</div>

<p class="fragment appear">
<code>apply</code> or <code>call</code>
</p>

</section>
</section>
<section>
<section id="slide-org74bbbeb">
<h2 id="org74bbbeb">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #5BA0EB;">vector</span>&lt;<span style="color: #5BA0EB;">T</span>&gt; <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">vector</span>&lt;<span style="color: #5BA0EB;">T</span>&gt;);
</pre>
</div>

<p class="fragment appear">
<code>reverse</code>, <code>shuffle</code>, &#x2026;
</p>

<aside class="notes">
<p>
For simplicity, I haven't written this signature in terms of iterators, but it
would be just the same.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orge8b1619">
<h2 id="orge8b1619">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #5BA0EB;">T</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">vector</span>&lt;<span style="color: #5BA0EB;">T</span>&gt;);
</pre>
</div>

<p class="fragment appear">
Not possible! It's a partial function - the <code>vector</code> might be empty.
</p>

<div class="org-src-container">

<pre  class="fragment appear">T&amp; <span style="color: #FFC287;">vector</span>&lt;T&gt;::front();
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org58067c8">
<h2 id="org58067c8">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #5BA0EB;">optional</span>&lt;<span style="color: #5BA0EB;">T</span>&gt; <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">vector</span>&lt;<span style="color: #5BA0EB;">T</span>&gt;);
</pre>
</div>

</section>
</section>
<section>
<section id="slide-orga5f4010">
<h2 id="orga5f4010">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>, <span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">U</span>&gt;
<span style="color: #5BA0EB;">vector</span>&lt;<span style="color: #5BA0EB;">U</span>&gt; <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">function</span>&lt;<span style="color: #AF81F4;">U</span>(<span style="color: #5BA0EB;">T</span>)&gt;, <span style="color: #5BA0EB;">vector</span>&lt;<span style="color: #5BA0EB;">T</span>&gt;);
</pre>
</div>

<p class="fragment appear">
<code>transform</code>
</p>

</section>
</section>
<section>
<section id="slide-org362cbe9">
<h2 id="org362cbe9">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #5BA0EB;">vector</span>&lt;<span style="color: #5BA0EB;">T</span>&gt; <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">function</span>&lt;<span style="color: #5BA0EB;">bool</span>(<span style="color: #5BA0EB;">T</span>)&gt;, <span style="color: #5BA0EB;">vector</span>&lt;<span style="color: #5BA0EB;">T</span>&gt;);
</pre>
</div>

<p class="fragment appear">
<code>remove_if</code>, <code>partition</code>, &#x2026;
</p>

</section>
</section>
<section>
<section id="slide-orgf92a244">
<h2 id="orgf92a244">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #5BA0EB;">T</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">optional</span>&lt;<span style="color: #5BA0EB;">T</span>&gt;);
</pre>
</div>

<p class="fragment appear">
Not possible!
</p>

</section>
</section>
<section>
<section id="slide-org87d089a">
<h2 id="org87d089a">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">K</span>, <span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">V</span>&gt;
<span style="color: #5BA0EB;">V</span> <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">map</span>&lt;<span style="color: #5BA0EB;">K</span>, <span style="color: #5BA0EB;">V</span>&gt;, <span style="color: #5BA0EB;">K</span>);
</pre>
</div>

<p class="fragment appear">
Not possible! (The key might not be in the <code>map</code>.)
</p>

<div class="org-src-container">

<pre  class="fragment appear">V&amp; <span style="color: #FFC287;">map</span>&lt;K, V&gt;::<span style="color: #8AC6F2;">operator</span>[](<span style="color: #8AC6F2;">const</span> <span style="color: #5BA0EB;">K</span>&amp;);
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org6111128">
<h2 id="org6111128">Name That Function</h2>
<br/>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">K</span>, <span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">V</span>&gt;
<span style="color: #5BA0EB;">optional</span>&lt;<span style="color: #5BA0EB;">V</span>&gt; <span style="color: #AF81F4;">f</span>(<span style="color: #5BA0EB;">map</span>&lt;<span style="color: #5BA0EB;">K</span>, <span style="color: #5BA0EB;">V</span>&gt;, <span style="color: #5BA0EB;">K</span>);
</pre>
</div>

<p class="fragment appear">
<code>lookup</code>
</p>

</section>
</section>
<section>
<section id="slide-orgd5bc744">
<h2 id="orgd5bc744">What Just Happened?</h2>
<p>
I gave you <i>almost nothing</i>.
</p>

<p>
No variable names. No function names. No type names.
</p>

<p>
Just bare type signatures.
</p>

<p class="fragment appear">
You were able to tell me exactly what the functions should be called, and likely
knew instantly how to implement them.
</p>

<p class="fragment appear">
You will note that partial functions gave us some issues&#x2026;
</p>

<aside class="notes">
<p>
Naming is one of the hardest problems in Comp Sci. Getting the types right is
much easier. And if your types model the logic properly, perhaps you have
"self-documenting code"?
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgbe8d6bd">
<h2 id="orgbe8d6bd">Well-typed Functions</h2>
<br/>
<p>
Writing <i>total functions</i> with well-typed signatures can tell us a lot about
functionality.
</p>

<p>
Using types appropriately makes interfaces unsurprising, safer to use and harder
to misuse.
</p>

<p>
Total functions make more test categories vanish.
</p>

</section>
</section>
<section>
<section id="slide-orgd3fdd82">
<h2 id="orgd3fdd82">About Testing&#x2026;</h2>
<p>
In a previous talk, I talked about unit testing and in particular property-based testing.
</p>

<p class="fragment appear">
Effectively using types can reduce test code.
</p>

<p class="fragment appear">
Property-based tests say "for all values, this property is true".
</p>

<p class="fragment appear">
That is exactly what types <i>are</i>: universal quantifications about what can be
done with data.
</p>

<p class="fragment appear">
Types scale better than tests. Instead of TDD, maybe try TDD!
</p>

<aside class="notes">
<p>
C++'s type system isn't yet powerful enough to be able to say goodbye to tests,
but it is powerful enough that used effectively, we can reduce some of the
drudgery of writing tests.
</p>

<p>
Any time you're thinking something is true for all values, that's what a type
can do.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org577a922">
<h2 id="org577a922">Further Down the Rabbit Hole</h2>
<br/>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Algebraic_data_type">http://en.wikipedia.org/wiki/Algebraic_data_type</a></li>
<li><a href="http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/">http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/</a></li>
<li><a href="https://vimeo.com/14313378">https://vimeo.com/14313378</a> (Effective ML: Making Illegal States Unrepresentable)</li>
<li><a href="http://www.infoq.com/presentations/Types-Tests">http://www.infoq.com/presentations/Types-Tests</a> (Types vs Tests: Strange Loop 2012)</li>

</ul>

</section>
</section>
<section>
<section id="slide-org05a1676">
<h2 id="org05a1676">Thanks For Listening</h2>
<br/>
<p>
"On the whole, I'm inclined to say that when in doubt, make a new type."
</p>
<div align="right">
<p>
&#x2013; Martin Fowler, <a href="http://martinfowler.com/ieeeSoftware/whenType.pdf"><i>When to Make a Type</i></a>
</p>
</div><br/>
<p>
"Don't set a flag; set the data."
</p>
<div align="right">
<p>
&#x2013; Leo Brodie, <i><a href="http://thinking-forth.sourceforge.net/">Thinking Forth</a></i>
</p>
</div>

</section>
</section>
<section>
<section id="slide-org2d3fb7d">
<h2 id="org2d3fb7d">Goals for Well-typed Code</h2>
<ul>
<li>Make illegal states unrepresentable</li>
<li>Use <code>std::variant</code> and <code>std::optional</code> for formulations that
<ul>
<li>are more natural</li>
<li>fit the business logic state better</li>

</ul></li>
<li>Use phantom types for safety
<ul>
<li>Make illegal behaviour a compile error</li>

</ul></li>
<li>Write total functions
<ul>
<li>Unsurprising behaviour</li>
<li>Easy to use, hard to misuse</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org0b86b02">
<h2 id="org0b86b02">Epilogue</h2>
<p>
A taste of algebra with datatypes
</p>

</section>
</section>
<section>
<section id="slide-org01f522c">
<h2 id="org01f522c">A Taste of Algebra with Datatypes</h2>
<p>
How many values?
</p>
<div class="org-src-container">

<pre  class="src src-cpp"><span style="color: #8AC6F2;">template</span> &lt;<span style="color: #8AC6F2;">typename</span> <span style="color: #5BA0EB;">T</span>&gt;
<span style="color: #8AC6F2;">class</span> <span style="color: #5BA0EB;">vector</span>&lt;<span style="color: #5BA0EB;">T</span>&gt;;
</pre>
</div>

<p class="fragment appear">
We can define a <code>vector&lt;T&gt;</code> recursively:
</p>

<p class="fragment appear">
\({v(t)} = {1 + t v(t)}\)
</p>

<p class="fragment appear">
(empty vector or (+) head element and (*) tail vector)
</p>

</section>
</section>
<section>
<section id="slide-org07b74b4">
<h2 id="org07b74b4">A Taste of Algebra with Datatypes</h2>
<p>
And rearrange&#x2026;
</p>

<p class="fragment appear">
What does that mean? Subtracting and dividing types?
</p>

</section>
</section>
<section>
<section id="slide-orgfa3ab39">
<h2 id="orgfa3ab39">A Taste of Algebra with Datatypes</h2>
<p>
When we don't know how to interpret something mathematical?
</p>

<p class="fragment appear">Let's <a href="http://www.wolframalpha.com/input/?i=1/(1-t)" data-preview-link>ask Wolfram Alpha</a>.</p>

</section>
</section>
<section>
<section id="slide-org0940f70">
<h2 id="org0940f70">A Taste of Algebra with Datatypes</h2>
<p>
Series expansion at \({t = 0}\):
</p>

<p>
\({1 + t + t^2 + t^3 + t^4 +{ }...}\)
</p>

<p class="fragment appear">
A <code>vector&lt;T&gt;</code> can have:
</p>
<ul>
<li class="fragment appear">0 elements (\({1}\))</li>
<li class="fragment appear">or (+) 1 element (\({t}\))</li>
<li class="fragment appear">or (+) 2 elements (\({t^2}\))</li>
<li class="fragment appear">etc.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgcb107ff">
<h2 id="orgcb107ff">Goals for Well-typed Code</h2>
<ul>
<li>Make illegal states unrepresentable</li>
<li>Use <code>std::variant</code> and <code>std::optional</code> for formulations that
<ul>
<li>are more natural</li>
<li>fit the business logic state better</li>

</ul></li>
<li>Use phantom types for safety
<ul>
<li>Make illegal behaviour a compile error</li>

</ul></li>
<li>Write total functions
<ul>
<li>Unsurprising behaviour</li>
<li>Easy to use, hard to misuse</li>

</ul></li>

</ul>
</section>
</section>
</div>
</div>
<script src="../../reveal.js/lib/js/head.min.js"></script>
<script src="../../reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: false,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1200,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
